---
title: C++面试精要
date: 2022-03-19 20:28:03
permalink: /pages/701574/
categories: 
  - cpp
tags: 
  - 
---

## C++程序编译过程

预处理：处理#开头的命令

编译、优化：将源码翻译成.s结尾的汇编代码

汇编：将汇编代码翻译成机器指令的代码.o结尾，被称为目标文件

链接：3种方式

- 静态链接：将代码从所在的静态链接库中被拷贝到最终的可执行文件，最终这些静态库的代码才可以加载到进程的虚拟地址空间。静态链接库实际是一个目标文件的集合。
- 动态链接：链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。

静态链接 优点：运行速度快 缺点：增加可执行文件大小 

动态链接 优点：可执行文件比较小  缺点：运行性能会损失

## const

### 变量

被修饰的变量无法修改

```cpp
const int a = 1;
```

### 指针

```cpp
int a = 1;
// 被修饰指针指向的变量无法修改
const int * p = &a;
// 被修改指针，只能指向一个固定变量
int * const p = &a;
```

### 引用

指向常量的引用，引用无法修改

```cpp
int b = 1;
const &a = b; 
```

### 成员函数

说明该成员函数内不能修改成员变量

## static

### 变量

#### 全局变量

> 修改全局变量，只能在当前源文件中使用

#### 局部函数

生命周期：整个程序

存储位置：静态区

使用范围：只能在作用域内使用

### 函数

#### 普通函数

使用范围：只能在当前源文件中使用

#### 成员函数

不能访问非静态成员变量，可以访问静态成员变量

通过classname::func使用，不需要生成对象也可以

## inline函数

在编译期，可以直接将函数内容在调用的处进行替换，不需要调用函数了

优点：省去函数调用，地址切换，参数压栈，栈空间使用与回收，提高程序运行

缺点：会使代码膨胀

## C++内存管理

堆：局部变量、函数参数、返回地址，由编译器自动分配和释放

栈：动态申请的内存，用程序员手动申请和释放，如果程序执行结束还没有释放，操作系统会自动回收

全局区/静态存储区：存放全局变量和静态变量，程序运行结束操作系统自动释放

常量区：存放常量，不允许修改，程序运行结束自动释放

代码区：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

## 栈和堆的区别

栈：

堆：



## 变量的区别

### 全局变量 

全局作用域，一个源文件定义，多个源文件可以使用，其他源文件需要使用，需要使用extern声明。

### 静态全局变量

这种全局变量只能在当前源文件中使用，

### 局部变量

在局部作用域中使用，离开作用域就会被释放，内存也会被回收

### 静态局部变量

只能在局部作用域中使用，但是它的生命周期在整个程序结束才会被释放。



## 如何避免拷贝

- 定义一个基类，将其中的拷贝构造函数和赋值构造函数生命为私有private
- 派生类以私有private的方式继承基类

```cpp
class Uncopyable
{
public:
    Uncopyable() {}
    ~Uncopyable() {}

private:
    Uncopyable(const Uncopyable &);            // 拷贝构造函数
    Uncopyable &operator=(const Uncopyable &); // 赋值构造函数
};
class A : private Uncopyable // 注意继承方式
{ 
};

```

C++可以使用delete关键字

```cpp
class noncopyable {
protected:
    noncopyable() = default;
    ~noncopyable() = default;
public:
    noncopyable(const noncopyable&) = delete;
    noncopyable& operator=(const noncopyable&) = delete;
};

class foo : private noncopyable { 
};
```

## 多重继承时会出现什么状况？如何解决？

多重继承（多继承）：是指从多个直接基类中产生派生类。

多重继承容易出现的问题：命名冲突和数据冗余问题。

## 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？

对于空类声明时，编辑器不会生成任何的成员函数，只会生成1个字节的占位符



空类定义时，编译器会生成6个成员函数

```cpp
#include <iostream>
using namespace std;
/*
class A
{}; 该空类的等价写法如下：
*/
class A
{
public:
    A(){};                                       // 缺省构造函数
    A(const A &tmp){};                           // 拷贝构造函数
    ~A(){};                                      // 析构函数
    A &operator=(const A &tmp){};                // 赋值运算符
    A *operator&() { return this; };             // 取址运算符
    const A *operator&() const { return this; }; // 取址运算符（const 版本）
};

int main()
{
    A *p = new A(); 
    cout << "sizeof(A):" << sizeof(A) << endl; // sizeof(A):1
    delete p;       
    return 0;
}
```

## 为什么拷贝构造函数必须为引用？

原因：避免拷贝构造函数无限制的递归，最终导致栈溢出。



## 如何禁止一个类被实例化

方法一：

在类中定义一个纯虚函数，使该类成为抽象基类，因为不能创建抽象基类的实例化对象；

方法二：

将类的构造函数声明为私有 `private`

## 为什么用成员初始化列表会快一些？

对于用户自定义类型，利用成员初始化列表效率高。

## 实例化一个对象需要哪几个阶段

- 分配空间
- 初始化
- 赋值

## 友元函数的作用及使用场景

友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。

## 深拷贝和浅拷贝的区别

如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。

## 如何让类不能被继承？

方法一

借助 `final` 关键字，用该关键字修饰的类不能被继承。

```cpp
#include <iostream>

using namespace std;

class Base final
{
};

class Derive: public Base{ // error: cannot derive from 'final' base 'Base' in derived type 'Derive'

};

int main()
{
    Derive ex;
    return 0;
}
```



方法二：

借助友元、虚继承和私有构造函数来实现

## STL

### 迭代器失效

插入操作

vector，如果容器内存被重新分配，插入点之前的不会失效，插入点之后的迭代器会失效。

deque，在中间插入，迭代器会失效，当我们插入元素front和back是，deque的迭代器会失效，但referenc和pointers有效



删除操作

对于vector，删除点之前的有效，之后的无效

对于deque