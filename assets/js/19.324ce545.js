(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{493:function(t,a,s){"use strict";s.r(a);var r=s(40),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"工厂模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[t._v("#")]),t._v(" 工厂模式")]),t._v(" "),s("h2",{attrs:{id:"简单工厂模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂模式"}},[t._v("#")]),t._v(" 简单工厂模式")]),t._v(" "),s("p",[t._v("在工厂类中做判断，增加新产品时，需要修改工厂类。")]),t._v(" "),s("blockquote",[s("p",[t._v("一个工厂类创建所有产品")])]),t._v(" "),s("p",[t._v("缺点： 工厂类集中所有产品的创建逻辑，如果产品量比较大，会使工厂类的非常臃肿 n")]),t._v(" "),s("h2",{attrs:{id:"工厂方法模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法模式"}},[t._v("#")]),t._v(" 工厂方法模式")]),t._v(" "),s("p",[t._v("产品抽象类、工厂抽象类， 使用子类具体实现这个接口以完成具体的创建工作，如果需要增加新的产品类，只需要扩展一个相应的工厂类")]),t._v(" "),s("blockquote",[s("p",[t._v("一个工厂对应一个产品")])]),t._v(" "),s("p",[t._v("缺点：产品类数据较多时，需要实现大量的工厂类")]),t._v(" "),s("h2",{attrs:{id:"抽象工厂模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式"}},[t._v("#")]),t._v(" 抽象工厂模式")]),t._v(" "),s("blockquote",[s("p",[t._v("增对系列产品")])]),t._v(" "),s("p",[t._v("缺点：当增加一个新系列的产品时，不仅需要实现具体的产品类，还需要增加一个新的创建接口，扩展相对困难")]),t._v(" "),s("h2",{attrs:{id:"策略模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[t._v("#")]),t._v(" 策略模式")]),t._v(" "),s("blockquote",[s("p",[t._v("使用策略模式可以降低复杂度，使得代码更容易维护")])]),t._v(" "),s("p",[t._v("缺点：可能需要定义大量的策略类，并且这些策略类都要提供供给客户端")]),t._v(" "),s("h2",{attrs:{id:"适配器模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[t._v("#")]),t._v(" 适配器模式")]),t._v(" "),s("p",[t._v("缺点：过多地使用适配器，会让系统非常零乱")])])}),[],!1,null,null,null);a.default=v.exports}}]);